/**
 * @file chronos_capture.h
 * @brief Chronos Multi-Camera Capture Library
 *
 * @copyright Copyright (C) 2025 Chronos Project
 * @license MIT License
 *
 * @details
 * This library provides a high-level C API for synchronized multi-camera
 * capture with zero-copy GPU memory access on the NVIDIA Jetson platform.
 *
 * Key Features:
 * - Synchronized capture from 4 OV9281 global shutter cameras
 * - Zero-copy path from camera to GPU memory
 * - Integrated IMU data with camera timestamps
 * - CUDA-EGL interop for direct GPU processing
 * - Triple-buffering to prevent frame drops
 *
 * Basic Usage:
 * @code
 *   // Initialize
 *   chronos_init();
 *
 *   // Configure
 *   chronos_config_t config = {
 *       .frame_rate = 60,
 *       .exposure_us = 5000,
 *       .external_trigger = true,
 *   };
 *   chronos_configure(&config);
 *
 *   // Capture loop
 *   chronos_start_capture();
 *   while (running) {
 *       chronos_sync_frame_set_t frames;
 *       if (chronos_get_frame_set(&frames, 1000) == CHRONOS_OK) {
 *           // Process frames with CUDA
 *           void *gpu_ptr;
 *           chronos_get_cuda_ptr(&frames.frames[0], &gpu_ptr);
 *           // ... run CUDA kernels ...
 *           chronos_release_frame_set(&frames);
 *       }
 *   }
 *   chronos_stop_capture();
 *   chronos_shutdown();
 * @endcode
 *
 * Thread Safety:
 * - chronos_init/shutdown must be called from main thread
 * - Other functions are thread-safe when called with different frame sets
 * - Callback mode runs in a dedicated capture thread
 *
 * Memory Model:
 * - Frames are allocated from a fixed pool (triple-buffered by default)
 * - chronos_release_frame_set() MUST be called to return frames to pool
 * - CUDA pointers remain valid until frame is released
 */

#ifndef CHRONOS_CAPTURE_H
#define CHRONOS_CAPTURE_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * =============================================================================
 * Constants
 * =============================================================================
 */

/** Number of synchronized cameras in the system */
#define CHRONOS_NUM_CAMERAS     4

/** Frame dimensions (OV9281 native resolution) */
#define CHRONOS_FRAME_WIDTH     1280
#define CHRONOS_FRAME_HEIGHT    800

/** Bytes per pixel (10-bit packed into 16-bit) */
#define CHRONOS_FRAME_BPP       2

/** Default number of buffers per camera (triple buffering) */
#define CHRONOS_BUFFER_COUNT    3

/*
 * =============================================================================
 * Error Codes
 * =============================================================================
 */

/**
 * @brief Error codes returned by Chronos API functions
 *
 * All API functions return chronos_error_t. Success is indicated by
 * CHRONOS_OK (0). Negative values indicate errors.
 */
typedef enum {
    /** Operation completed successfully */
    CHRONOS_OK = 0,

    /** Initialization failed (device not found, driver error, etc.) */
    CHRONOS_ERROR_INIT = -1,

    /** Capture operation failed (streaming error, device error) */
    CHRONOS_ERROR_CAPTURE = -2,

    /** Memory allocation failed */
    CHRONOS_ERROR_MEMORY = -3,

    /** CUDA operation failed */
    CHRONOS_ERROR_CUDA = -4,

    /** Operation timed out */
    CHRONOS_ERROR_TIMEOUT = -5,

    /** Synchronization error (frames not aligned) */
    CHRONOS_ERROR_SYNC = -6,

    /** Invalid parameter passed to function */
    CHRONOS_ERROR_PARAM = -7,
} chronos_error_t;

/*
 * =============================================================================
 * Data Structures
 * =============================================================================
 */

/**
 * @brief Metadata associated with each captured frame
 *
 * This structure contains timing and configuration information
 * for a single camera frame.
 */
typedef struct {
    /**
     * @brief Frame timestamp in nanoseconds (CLOCK_MONOTONIC)
     *
     * This timestamp is generated by the kernel when the frame
     * is received. For synchronized cameras, timestamps should
     * be within ~100µs of each other.
     */
    uint64_t timestamp_ns;

    /**
     * @brief Frame sequence number
     *
     * Monotonically increasing counter. Can be used to detect
     * dropped frames (gaps in sequence).
     */
    uint32_t sequence;

    /** Camera index (0-3) */
    uint32_t camera_id;

    /** Virtual channel ID from FPGA (matches camera_id) */
    uint32_t vc_id;

    /**
     * @brief Synchronization status
     *
     * True if this frame was captured in response to a valid
     * sync trigger. False if free-running or trigger missed.
     */
    bool sync_valid;

    /** Exposure time in microseconds (as configured) */
    uint32_t exposure_us;

    /** Analog gain in decibels */
    float gain_db;
} chronos_frame_meta_t;

/**
 * @brief Single camera frame buffer
 *
 * This structure provides access to frame data through multiple
 * interfaces (CPU, GPU, DMA). Only use the appropriate pointer
 * for your access pattern.
 */
typedef struct {
    /**
     * @brief CPU-accessible pointer
     *
     * Only valid after calling chronos_map_cpu(). NULL if not mapped.
     * Avoid CPU access when possible - use CUDA for processing.
     */
    void *data;

    /**
     * @brief CUDA device pointer
     *
     * Valid after calling chronos_get_cuda_ptr() or chronos_cuda_map().
     * This is a zero-copy pointer - no memcpy needed!
     */
    void *cuda_ptr;

    /** DMA-BUF file descriptor for external sharing */
    int dmabuf_fd;

    /** NvBuffer file descriptor (Jetson-specific) */
    int nvbuf_fd;

    /** Frame width in pixels */
    uint32_t width;

    /** Frame height in pixels */
    uint32_t height;

    /** Row pitch in bytes (may include padding) */
    uint32_t pitch;

    /** Total buffer size in bytes */
    uint32_t size;

    /** Frame metadata (timestamp, sequence, etc.) */
    chronos_frame_meta_t meta;
} chronos_frame_t;

/**
 * @brief IMU data sample
 *
 * Contains synchronized accelerometer and gyroscope readings.
 * The timestamp corresponds to the same trigger that captured
 * the camera frames.
 */
typedef struct {
    /**
     * @brief IMU sample timestamp (nanoseconds)
     *
     * Should be within ~10µs of camera frame timestamps when
     * synchronization is working correctly.
     */
    uint64_t timestamp_ns;

    /**
     * @brief Accelerometer readings [X, Y, Z] in m/s²
     *
     * Coordinate system:
     * - X: Right (when viewing cameras)
     * - Y: Down
     * - Z: Forward (camera optical axis)
     */
    float accel[3];

    /**
     * @brief Gyroscope readings [X, Y, Z] in rad/s
     *
     * Same coordinate system as accelerometer.
     * Positive values indicate counter-clockwise rotation.
     */
    float gyro[3];

    /** IMU temperature in Celsius */
    float temp;

    /** Number of sync pulses received by IMU */
    uint64_t sync_count;
} chronos_imu_data_t;

/**
 * @brief Synchronized frame set from all cameras
 *
 * Contains frames from all 4 cameras captured at the same instant,
 * plus synchronized IMU data.
 */
typedef struct {
    /** Array of frames, one per camera (indexed by camera_id) */
    chronos_frame_t frames[CHRONOS_NUM_CAMERAS];

    /** IMU data captured at same trigger instant */
    chronos_imu_data_t imu;

    /** Trigger timestamp (reference for all sensors) */
    uint64_t sync_timestamp_ns;

    /** Sync sequence number (matches frame sequences) */
    uint32_t sync_sequence;

    /**
     * @brief Frame set completeness flag
     *
     * True if all 4 cameras delivered frames for this trigger.
     * False if any camera dropped a frame.
     */
    bool complete;
} chronos_sync_frame_set_t;

/**
 * @brief Capture configuration parameters
 *
 * Pass to chronos_configure() to set capture parameters.
 * All fields have reasonable defaults if set to 0.
 */
typedef struct {
    /**
     * @brief Target frame rate (1-120 fps)
     *
     * Actual achievable rate depends on exposure time.
     * Default: 30 fps
     */
    uint32_t frame_rate;

    /**
     * @brief Exposure time in microseconds
     *
     * Must be less than frame period (1/frame_rate).
     * Default: 5000 µs (5ms)
     */
    uint32_t exposure_us;

    /**
     * @brief Analog gain in decibels
     *
     * Range: 0 to 24 dB (approximately)
     * Default: 0 dB (1x gain)
     */
    float gain_db;

    /**
     * @brief Use external trigger mode
     *
     * When true, cameras sync to FPGA trigger pulses.
     * When false, cameras run at internal timing.
     * Default: true (synchronized)
     */
    bool external_trigger;

    /**
     * @brief Enable IMU capture
     *
     * When true, IMU data is included in frame sets.
     * Default: true
     */
    bool enable_imu;

    /**
     * @brief Number of frame buffers per camera
     *
     * Higher values reduce dropped frames but increase memory.
     * Default: 3 (triple buffering)
     */
    uint32_t buffer_count;
} chronos_config_t;

/**
 * @brief Callback function type for asynchronous capture
 *
 * @param frame_set Pointer to captured frame set (valid only during callback)
 * @param user_data User data pointer from chronos_set_frame_callback()
 *
 * @warning The callback runs in the capture thread. Keep processing minimal
 * or copy data for processing elsewhere. Call chronos_release_frame_set()
 * before returning from the callback.
 */
typedef void (*chronos_frame_callback_t)(chronos_sync_frame_set_t *frame_set,
                                         void *user_data);

/*
 * =============================================================================
 * Initialization and Configuration
 * =============================================================================
 */

/**
 * @brief Initialize the Chronos capture system
 *
 * Initializes all hardware components:
 * - Opens V4L2 video devices for all 4 cameras
 * - Initializes CUDA context and EGL interop
 * - Opens IMU device
 * - Allocates NvBuffer pools for zero-copy capture
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_INIT if devices not found or initialization fails
 * @return CHRONOS_ERROR_CUDA if CUDA initialization fails
 *
 * @note Must be called before any other Chronos functions
 * @note Call chronos_shutdown() when done, even if init fails partially
 */
chronos_error_t chronos_init(void);

/**
 * @brief Shutdown the Chronos capture system
 *
 * Stops any active capture and releases all resources:
 * - Stops camera streaming
 * - Frees CUDA resources
 * - Closes device handles
 * - Frees buffer memory
 *
 * @note Safe to call even if chronos_init() failed or wasn't called
 * @note After shutdown, chronos_init() can be called again
 */
void chronos_shutdown(void);

/**
 * @brief Configure capture parameters
 *
 * Updates capture settings. Can only be called when not streaming.
 *
 * @param config Pointer to configuration structure
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_PARAM if config is NULL or values invalid
 * @return CHRONOS_ERROR_CAPTURE if called while streaming
 *
 * @note Changes take effect on next chronos_start_capture()
 */
chronos_error_t chronos_configure(const chronos_config_t *config);

/**
 * @brief Get current configuration
 *
 * @param config Pointer to structure to fill with current settings
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_PARAM if config is NULL
 */
chronos_error_t chronos_get_config(chronos_config_t *config);

/*
 * =============================================================================
 * Capture Control
 * =============================================================================
 */

/**
 * @brief Start capturing frames
 *
 * Begins synchronized capture from all cameras:
 * - Queues buffers to all camera devices
 * - Starts V4L2 streaming on all cameras
 * - Enables FPGA trigger (if external_trigger = true)
 * - Starts capture thread
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_CAPTURE if streaming fails to start
 * @return CHRONOS_ERROR_INIT if not initialized
 *
 * @note Frames can be retrieved with chronos_get_frame_set() or via callback
 */
chronos_error_t chronos_start_capture(void);

/**
 * @brief Stop capturing frames
 *
 * Stops synchronized capture:
 * - Disables FPGA trigger
 * - Stops V4L2 streaming
 * - Stops capture thread
 * - Returns queued buffers
 *
 * @return CHRONOS_OK on success
 *
 * @note Safe to call even if not streaming
 */
chronos_error_t chronos_stop_capture(void);

/**
 * @brief Check if capture is running
 *
 * @return true if chronos_start_capture() was called and capture is active
 * @return false otherwise
 */
bool chronos_is_capturing(void);

/*
 * =============================================================================
 * Frame Acquisition
 * =============================================================================
 */

/**
 * @brief Get next synchronized frame set (blocking)
 *
 * Waits for a complete synchronized frame set from all cameras.
 * This is the primary function for polling-mode capture.
 *
 * @param frame_set Pointer to structure to fill with frame data
 * @param timeout_ms Maximum time to wait in milliseconds
 *                   Use -1 for infinite wait
 *
 * @return CHRONOS_OK on success (frame_set is filled)
 * @return CHRONOS_ERROR_TIMEOUT if timeout expires
 * @return CHRONOS_ERROR_PARAM if frame_set is NULL
 * @return CHRONOS_ERROR_CAPTURE if capture error occurs
 *
 * @warning Caller MUST call chronos_release_frame_set() after processing!
 *
 * @note If a callback is registered, this function is not needed
 */
chronos_error_t chronos_get_frame_set(chronos_sync_frame_set_t *frame_set,
                                       int timeout_ms);

/**
 * @brief Release a frame set back to the buffer pool
 *
 * Returns the frame buffers for reuse. Must be called after processing
 * each frame set obtained from chronos_get_frame_set() or callback.
 *
 * @param frame_set Frame set to release
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_PARAM if frame_set is NULL
 *
 * @warning Failing to call this function will cause buffer starvation!
 * @warning CUDA pointers become invalid after this call
 */
chronos_error_t chronos_release_frame_set(chronos_sync_frame_set_t *frame_set);

/**
 * @brief Register callback for asynchronous frame delivery
 *
 * When a callback is registered, frames are delivered asynchronously
 * instead of being queued for chronos_get_frame_set().
 *
 * @param callback Function to call for each frame set (NULL to disable)
 * @param user_data User pointer passed to callback
 *
 * @return CHRONOS_OK on success
 *
 * @note Callback runs in capture thread - keep processing brief!
 * @note Call chronos_release_frame_set() before returning from callback
 */
chronos_error_t chronos_set_frame_callback(chronos_frame_callback_t callback,
                                            void *user_data);

/*
 * =============================================================================
 * CUDA Integration (Zero-Copy GPU Access)
 * =============================================================================
 */

/**
 * @brief Get CUDA pointer for a frame (zero-copy)
 *
 * Maps the frame buffer to CUDA and returns a device pointer that
 * can be used directly in CUDA kernels. This is a zero-copy operation -
 * the data remains in place, no memcpy is performed.
 *
 * @param frame Frame to get CUDA pointer for
 * @param cuda_ptr Pointer to store the CUDA device pointer
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_PARAM if frame or cuda_ptr is NULL
 * @return CHRONOS_ERROR_CUDA if CUDA mapping fails
 *
 * @note Pointer remains valid until chronos_release_frame_set()
 * @note Frame is automatically mapped if not already mapped
 */
chronos_error_t chronos_get_cuda_ptr(chronos_frame_t *frame, void **cuda_ptr);

/**
 * @brief Explicitly map frame to CUDA
 *
 * Maps the frame for CUDA access. Usually not needed - chronos_get_cuda_ptr()
 * performs mapping automatically.
 *
 * @param frame Frame to map
 *
 * @return CHRONOS_OK on success
 */
chronos_error_t chronos_cuda_map(chronos_frame_t *frame);

/**
 * @brief Unmap frame from CUDA
 *
 * Releases CUDA mapping for the frame. Usually not needed - mapping
 * is released automatically by chronos_release_frame_set().
 *
 * @param frame Frame to unmap
 *
 * @return CHRONOS_OK on success
 */
chronos_error_t chronos_cuda_unmap(chronos_frame_t *frame);

/*
 * =============================================================================
 * IMU Access
 * =============================================================================
 */

/**
 * @brief Get latest IMU data
 *
 * Returns the most recent IMU reading, independent of camera frames.
 * For synchronized data, use the imu field of chronos_sync_frame_set_t.
 *
 * @param imu_data Pointer to structure to fill
 *
 * @return CHRONOS_OK on success
 * @return CHRONOS_ERROR_PARAM if imu_data is NULL
 * @return CHRONOS_ERROR_INIT if IMU not initialized/enabled
 */
chronos_error_t chronos_get_imu_data(chronos_imu_data_t *imu_data);

/*
 * =============================================================================
 * Statistics and Diagnostics
 * =============================================================================
 */

/**
 * @brief Capture statistics structure
 *
 * Contains counters and metrics for monitoring capture health.
 */
typedef struct {
    /** Frames successfully captured per camera */
    uint64_t frames_captured[CHRONOS_NUM_CAMERAS];

    /** Frames dropped per camera (detected by sequence gaps) */
    uint64_t frames_dropped[CHRONOS_NUM_CAMERAS];

    /** Number of sync errors (incomplete frame sets) */
    uint64_t sync_errors;

    /** Buffer overrun count (frames lost due to slow processing) */
    uint64_t buffer_overruns;

    /** Average capture-to-delivery latency in microseconds */
    float avg_latency_us;

    /** Maximum observed inter-camera sync skew in microseconds */
    float max_sync_skew_us;

    /** Current measured frame rate */
    uint32_t current_fps;
} chronos_stats_t;

/**
 * @brief Get capture statistics
 *
 * @param stats Pointer to structure to fill
 *
 * @return CHRONOS_OK on success
 */
chronos_error_t chronos_get_stats(chronos_stats_t *stats);

/**
 * @brief Reset statistics counters
 *
 * Clears all statistics counters to zero.
 */
void chronos_reset_stats(void);

/**
 * @brief Get human-readable error string
 *
 * @param error Error code to describe
 *
 * @return Pointer to static string describing the error
 */
const char *chronos_strerror(chronos_error_t error);

#ifdef __cplusplus
}
#endif

#endif /* CHRONOS_CAPTURE_H */
